#!/bin/sh /etc/rc.common

START=99
STOP=99

USE_PROCD=1

EXTRA_COMMANDS="check_version update"
EXTRA_HELP="        check_version   Check for updates
        update          Update qosmate"

REQUIRED_PACKAGES="kmod-sched ip-full kmod-veth tc-full kmod-netem kmod-sched-ctinfo kmod-ifb kmod-sched-cake"
SCRIPT_URL="https://raw.githubusercontent.com/hudra0/qosmate/main/etc/qosmate.sh"
HOTPLUG_SCRIPT_URL="https://raw.githubusercontent.com/hudra0/qosmate/main/etc/hotplug.d/iface/13-qosmateHotplug"

service_triggers() {
    procd_add_reload_trigger "network"
    procd_add_reload_trigger "firewall"
}

load_config() {
    config_load 'qosmate'
    config_get WAN settings 'WAN' 'eth1'
}

install_packages() {
    # Flag to indicate if opkg update is needed
    need_update=0

    # Check if any packages are missing
    for pkg in $REQUIRED_PACKAGES; do
        if ! opkg list-installed | grep -q "^$pkg "; then
            echo "$pkg is not installed."
            need_update=1
            break
        fi
    done

    # Run opkg update if at least one package is missing
    if [ "$need_update" -eq 1 ]; then
        echo "Updating opkg list..."
        opkg update
    fi

    # Install missing packages
    for pkg in $REQUIRED_PACKAGES; do
        if ! opkg list-installed | grep -q "^$pkg "; then
            echo "Installing $pkg..."
            opkg install "$pkg" || {
                echo "Failed to install $pkg."
                return 1 # Abort if the installation fails
            }
        fi
    done
}

download_scripts() {
    [ ! -f /etc/qosmate.sh ] && wget -O /etc/qosmate.sh $SCRIPT_URL && chmod a+x /etc/qosmate.sh
    [ ! -f /etc/hotplug.d/iface/13-qosmateHotplug ] && wget -O /etc/hotplug.d/iface/13-qosmateHotplug $HOTPLUG_SCRIPT_URL
    
    # Create the directory for tc-Netem distributions if it does not exist
    mkdir -p /usr/lib/tc

    # Base URL for the repository
    DIST_URL="https://raw.githubusercontent.com/hudra0/qosmate/main/usr/lib/tc"

    # List of files
    DIST_FILES="experimental.dist normal.dist normmix20-64.dist pareto.dist paretonormal.dist"

    # Iterate through the list and download each file
    for FILE in $DIST_FILES; do
        if [ ! -f "/usr/lib/tc/$FILE" ]; then
            echo "Downloading $FILE..."
            wget -O "/usr/lib/tc/$FILE" "$DIST_URL/$FILE" || echo "Error downloading $FILE"
        fi
    done
}

check_and_download_config() {
    local config_path="/etc/config/qosmate"
    if [ ! -f "$config_path" ]; then
        echo "Configuration file not found, downloading the latest version..."
        wget -O $config_path "https://raw.githubusercontent.com/hudra0/qosmate/main/etc/config/qosmate" || {
            echo "Error downloading configuration. Please check your internet connection and try again."
            return 1
        }
        echo "Configuration file downloaded successfully."
    else
        echo "Configuration file already exists."
    fi
}

migrate_config() {
    CONFIG_FILE="/etc/config/qosmate"

    # Function to add the global enabled option if it does not exist
    if ! grep -q "config global 'global'" $CONFIG_FILE; then
        echo "Adding global configuration section..."
        sed -i '1i\
config global '\''global'\''\n    option enabled '\''1'\''\n' $CONFIG_FILE
        echo "Global configuration section added."
    else
        echo "Global configuration section already exists."
    fi

    # Ensure the enabled option is present in the global section
    if ! grep -q "option enabled" $CONFIG_FILE; then
        echo "Adding enabled option to global section..."
        sed -i "/config global 'global'/a\\
    option enabled '1'
" $CONFIG_FILE
        echo "Enabled option added."
    else
        echo "Enabled option already exists."
    fi
}

start_service() {
    install_packages
    download_scripts
    check_and_download_config || return 1    
    migrate_config    
    /etc/qosmate.sh    
    /etc/init.d/firewall reload
    sed -i "s/\(option enabled\).*/\1 '1'/" /etc/config/qosmate
    echo "Service started" | logger -t qosmate    
    /etc/init.d/qosmate enable     
}

stop_service() {
    load_config    
    echo "Stopping service qosmate..."
    /etc/init.d/qosmate disable
    sed -i "s/\(option enabled\).*/\1 '0'/" /etc/config/qosmate
    ## Delete files
    rm -f /etc/hotplug.d/iface/13-qosmateHotplug
    rm -f /usr/share/nftables.d/ruleset-post/dscptag.nft

    ## Delete the old qdiscs created by the script
    tc qdisc del dev $WAN root > /dev/null 2>&1
    tc qdisc del dev ifb-$WAN root > /dev/null 2>&1
    tc qdisc del dev $WAN ingress > /dev/null 2>&1 

    # Remove IFB interface
    ip link del ifb-$WAN 2>/dev/null

    nft delete table inet dscptag

    echo "Reloading network service..."
    /etc/init.d/network reload
    /etc/init.d/firewall reload
    echo "Service stopped" | logger -t qosmate     
    exit 0
}

status_service() {
    # Load configuration
    . /lib/functions.sh
    config_load 'qosmate'

    # Function to extract default values from the main script
    get_default_value() {
        local var_name=$1
        local default_value=$(grep "^$var_name=" /etc/qosmate.sh | cut -d'=' -f2- | tr -d '"')
        echo "$default_value"
    }

    # Function to get current value or default
    get_current_or_default() {
        local uci_path=$1
        local default_value=$2
        local value=$(uci -q get $uci_path)
        if [ -z "$value" ]; then
            echo "$default_value (Default value)"
        else
            echo "$value"
        fi
    }

    # Extract default values
    DEFAULT_WAN=$(get_default_value "DEFAULT_WAN")
    DEFAULT_DOWNRATE=$(get_default_value "DEFAULT_DOWNRATE")
    DEFAULT_UPRATE=$(get_default_value "DEFAULT_UPRATE")
    DEFAULT_GAMEQDISC=$(get_default_value "gameqdisc")

    echo "==== qosmate Status ===="
    
    # Check if the service is enabled
    if /etc/init.d/qosmate enabled; then
        echo "qosmate service is enabled."
    else
        echo "qosmate service is not enabled."
    fi

    # Check if traffic shaping is active
    WAN=$(uci -q get qosmate.settings.WAN || echo "$DEFAULT_WAN")
    IFB="ifb-$WAN"
    
    if tc qdisc show dev $WAN 2>/dev/null | grep -q "qdisc cake"; then
        if /etc/init.d/qosmate enabled; then
            echo "Traffic shaping is active on the egress interface ($WAN)."
        else
            echo "Default CAKE qdisc is active on the egress interface ($WAN), but qosmate is not managing it."
        fi
    elif tc qdisc show dev $WAN 2>/dev/null | grep -q "qdisc hfsc"; then
        echo "Traffic shaping (HFSC) is active on the egress interface ($WAN)."
    else
        echo "No qosmate traffic shaping is active on the egress interface ($WAN)."
    fi

    if tc qdisc show dev $IFB 2>/dev/null | grep -q "qdisc cake\|qdisc hfsc"; then
        echo "Traffic shaping is active on the ingress interface ($IFB)."
    else
        echo "Traffic shaping is not active on the ingress interface ($IFB)."
    fi

    echo "==== Overall Status ===="
    # Determine if the service is actually running
    if /etc/init.d/qosmate enabled && { tc qdisc show dev $WAN 2>/dev/null | grep -q "qdisc hfsc" || tc qdisc show dev $IFB 2>/dev/null | grep -q "qdisc cake\|qdisc hfsc"; }; then
        echo "qosmate is currently active and managing traffic shaping."
    else
        echo "qosmate is not currently active or managing traffic shaping."
    fi

    echo "==== Current Settings ===="
    # Show summary of current settings
    echo "Upload rate: $(get_current_or_default qosmate.settings.UPRATE "$DEFAULT_UPRATE") kbps"
    echo "Download rate: $(get_current_or_default qosmate.settings.DOWNRATE "$DEFAULT_DOWNRATE") kbps"
    
    # For GAMEUP and GAMEDOWN, we need to evaluate the expressions
    UPRATE=$(uci -q get qosmate.settings.UPRATE || echo "$DEFAULT_UPRATE")
    DOWNRATE=$(uci -q get qosmate.settings.DOWNRATE || echo "$DEFAULT_DOWNRATE")
    DEFAULT_GAMEUP=$((UPRATE*15/100+400))
    DEFAULT_GAMEDOWN=$((DOWNRATE*15/100+400))
    
    echo "Game traffic upload: $(get_current_or_default qosmate.performance.GAMEUP "$DEFAULT_GAMEUP") kbps"
    echo "Game traffic download: $(get_current_or_default qosmate.performance.GAMEDOWN "$DEFAULT_GAMEDOWN") kbps"
    echo "Queue discipline: $(get_current_or_default qosmate.qdisc.gameqdisc "$DEFAULT_GAMEQDISC")"

    echo
    echo "==== Detailed Technical Information ===="
    echo "Traffic Control (tc) Queues:"
    tc -s qdisc

    echo
    echo "==== Nftables Ruleset (dscptag) ===="
    nft list ruleset | grep 'chain dscptag' -A 100
}

restart() {
    /etc/init.d/qosmate stop
    sleep 1 # Ensure all processes have been properly terminated
    /etc/init.d/qosmate start    
}

reload_service() {
    restart
}

check_version() {
    local current_version=$(grep '^VERSION=' /etc/qosmate.sh | cut -d'"' -f2)
    local latest_version=$(wget -qO- https://raw.githubusercontent.com/hudra0/qosmate/main/etc/qosmate.sh | grep '^VERSION=' | cut -d'"' -f2)
    
    if [ -z "$latest_version" ]; then
        echo "Error: Could not retrieve the latest version."
        return 1
    fi
    
    echo "Current version: $current_version"
    echo "Latest version: $latest_version"
    
    if [ "$current_version" != "$latest_version" ]; then
        echo "A new version of qosmate is available."
        echo "To update, run: /etc/init.d/qosmate update"
    else
        echo "qosmate is up to date."
    fi
}

update() {
    local current_version=$(grep '^VERSION=' /etc/qosmate.sh | cut -d'"' -f2)
    local latest_version=$(wget -qO- https://raw.githubusercontent.com/hudra0/qosmate/main/etc/qosmate.sh | grep '^VERSION=' | cut -d'"' -f2)
    
    if [ -z "$latest_version" ]; then
        echo "Error: Could not retrieve the latest version."
        return 1
    fi
    
    if [ "$current_version" = "$latest_version" ]; then
        echo "No update necessary. Current version ($current_version) is the latest."
        return 0
    fi
    
    echo "New version available: $latest_version"
    echo "Current version: $current_version"
    echo -n "Do you want to update? [y/N] "
    read answer
    if [ "$answer" != "y" ] && [ "$answer" != "Y" ]; then
        echo "Update cancelled."
        return 0
    fi
    
    echo "Updating qosmate..."
    if wget -O /etc/qosmate.sh https://raw.githubusercontent.com/hudra0/qosmate/main/etc/qosmate.sh && \
       wget -O /etc/init.d/qosmate https://raw.githubusercontent.com/hudra0/qosmate/main/etc/init.d/qosmate && \
       wget -O /etc/hotplug.d/iface/13-qosmateHotplug https://raw.githubusercontent.com/hudra0/qosmate/main/etc/hotplug.d/iface/13-qosmateHotplug; then
        chmod +x /etc/qosmate.sh /etc/init.d/qosmate
        echo "Update complete. Please restart qosmate."
        restart
    else
        echo "Update failed. Please try again later."
    fi
}
